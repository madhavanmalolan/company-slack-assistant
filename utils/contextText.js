const aboutReclaimLong = `
# Reclaim Protocol: Verifiable Web2 Data Portability

## What is Reclaim Protocol and What Problem Does It Solve?

Reclaim Protocol is an **infrastructure for accessing user-permissioned data from any website** and sharing it in a verifiable way. In simpler terms, it allows users to securely **transfer their online identity and reputation from one website to another**. This addresses a key problem: today, valuable data like your ratings, achievements, or account history are siloed on individual platforms (rideshare apps, banks, online schools, etc.), and there’s no easy, trustworthy way to **prove those credentials elsewhere**. Reclaim solves this by enabling users to **prove specific facts about their accounts (e.g. “5-star driver” or “never missed a credit card payment”) to other services** without revealing sensitive details. It emphasizes user control – you choose what parts of your data to share, and **the proof shows exactly where the data came from and that it wasn’t tampered with**.

In essence, Reclaim Protocol provides a toolkit for **verifiable data portability**. For example, you could ask a user to log in to their bank and prove their account balance to your service, or have them log in to Uber and prove they’ve taken 50+ rides this year – **all without any change on the bank’s or Uber’s side and without compromising the user’s security**. By using Reclaim, companies can streamline onboarding and verification: instead of uploading screenshots or trusting self-reported info, **users can supply cryptographically verified evidence of their credentials from other platforms**. This makes **onboarding faster and more trustworthy** across various domains (finance, hiring, lending, social, etc.), while **giving users control over their personal data**.

## How Reclaim Protocol Works (No Server Cooperation Required)

**Reclaim leverages a novel cryptographic workflow to fetch data from Web2 sites on behalf of the user, without requiring any integration or permission from those sites.** The core idea is to perform an **attested web session**: the user logs into the target website through Reclaim’s system, and a specialized node called an *attestor* observes the process and vouches for the result. Importantly, this is done **without “man-in-the-middle” decryption by the attestor** – the attestor acts as an **opaque proxy** for the HTTPS connection. The attestor cannot read or modify the data (it doesn’t have the TLS keys), but it can still **ensure the data truly came from the genuine website** and hasn’t been altered.

Here’s a step-by-step of a typical Reclaim verification flow:

1. **Initialization:** The user initiates a proof request (for example, to prove some data from example.com). The relying application (the service that needs the proof) specifies what data is needed. Under the hood, Reclaim knows the target URL and data location (via a predefined “provider” definition for that site).
2. **Secure Login via Attestor:** When it’s time to verify, the user is prompted to **log in to the target website through a secure in-app browser** session. This session’s traffic is **routed through the Reclaim attestor node**. The attestor forwards the encrypted HTTPS data between the user’s device and the website. Crucially, all data is end-to-end encrypted with TLS – the **attestor never sees the user’s plaintext credentials or content**. (Reclaim even allows the client to **conceal sensitive fields like passwords or auth tokens** from the attestor during this process.)
3. **Authenticity Checks:** As it proxies the connection, the attestor performs checks to guarantee authenticity. For instance, it validates the server’s TLS certificate to ensure the user is truly connecting to *example.com* and not a fake site, **protecting against DNS spoofing or BGP hijacking attacks**. The attestor also notes cryptographic signatures or hashes of the data stream to later prove integrity.
4. **Data Retrieval:** The user navigates and logs in normally. Once logged in, the specific page or API response containing the needed data is loaded (e.g. a dashboard showing “Your balance is \$5,000” or “You have 5-star rating”). The user’s device can **selectively reveal only the relevant piece of data** for the proof, while keeping other parts of the page private (this uses techniques like *TLS Request/Response Selective Reveal* in the cryptography).
5. **Claim Creation:** After the data is fetched, the user’s Reclaim client generates a **structured claim** describing the fact to prove (for example, *“User’s Uber ride count in 2023 is greater than 50”* or *“Account balance is \$5,000”*). This claim is prepared along with cryptographic evidence from the session.
6. **Attestation (Proof Signing):** The claim is sent to the attestor service, which now uses the evidence from the observed session to **verify that the claim matches what the real website returned**. The attestor **decrypts only the minimal data needed or uses zero-knowledge proof methods to check the claim**, without ever accessing unrelated info like passwords. Once satisfied, the attestor signs the claim, effectively issuing a **verifiable credential** about the user’s data. This signed proof is returned to the user (or directly to the requesting app).
7. **Verification:** The relying app or any third party can now verify the attestor’s signature on the claim. The attestor’s public key (or a decentralized attestor registry) is known, so the proof’s authenticity can be checked instantly. Because the attestor vouches it saw this data come from the genuine site, the relying party doesn’t need to contact the original site at all. The proof is **cryptographically tamper-proof and auditable** – meaning the app can trust the data without trusting the user blindly.

**No cooperation from the source website is required:** The entire flow uses the website’s existing front-end or API, just as a normal user interaction. From the website’s perspective, it’s just the user logging in and viewing their information. Technologies like earlier “TLS notary” or “TLS oracle” research demonstrated that a third party can attest to a TLS session’s contents, and Reclaim’s approach refines this to avoid custom server changes (unlike some prior solutions). In Reclaim’s model, **the server need not be aware of anything – the proof is generated purely on the client and attestor side**, making it universally applicable to virtually **any Web2 platform**.

Behind the scenes, Reclaim Protocol employs advanced cryptography to make this possible. **Transport Layer Security (TLS)** provides the encryption that keeps the user’s secrets safe (the attestor never breaks TLS encryption, it simply forwards packets). **Zero-knowledge proofs (ZKPs)** are used to allow selective disclosure – users can prove statements about the data (e.g. a threshold or specific field value) **without exposing all the data**. An essential concept is that the user’s device plays the role of prover, working with the attestor (verifier) in a secure multi-party protocol. The formal security analysis describes this as a three-party computation between the TLS server, the client, and the verifier, ensuring that *selective data provenance* is achieved without tipping off the server or letting the client cheat. Additionally, Reclaim uses cryptographic primitives like **Oblivious Pseudorandom Functions (OPRFs)** in certain steps to enhance privacy. For instance, an OPRF can derive a unique identifier or token from a user’s account info in a way that the attestor doesn’t learn the raw info and the user can’t spoof the outcome. These techniques make the protocol both robust and privacy-preserving.

## Unique Value Propositions of Reclaim Protocol

Reclaim Protocol offers several unique benefits and capabilities that set it apart as a verifiability solution:

* **Web2 Verification at Scale:** Reclaim can **verify data from essentially any website on the internet, at scale**. It’s not limited to a fixed set of integrations – by design it works with existing HTTPS endpoints universally. In fact, Reclaim boasts coverage of **thousands of data sources (2,500+ sites)** ranging from banks to social media to e-commerce. This broad compatibility means developers can tap into a user’s data on almost any platform. The infrastructure has already facilitated over a **million successful verifications** in the wild (a testament to its scalability and reliability). Importantly, this works **without asking permission from those sites** – no special APIs or partnerships needed. As the team puts it: *“Not just banks and Uber, you can connect to any website on the internet. Over 1000 already.”*. This level of coverage and flexibility in the Web2 world is unparalleled.

* **Global Data Access:** Because it’s based on standard web protocols, Reclaim enables **global access to data**. No matter where the data resides (any country or region), as long as a user can access their account, Reclaim can retrieve a proof from it. This is crucial for a global user base – for example, a lender in one country could accept verified financial info from a bank in another country via Reclaim, something traditionally very hard to do. The protocol isn’t constrained by geographic or regulatory silos; it leverages the open web. All a user needs is an internet connection to their target service. The **attestor network** is also globally distributed, ensuring low-latency access and reliability.

* **Versatile Data Points:** Reclaim isn’t limited to one type of credential – it’s extremely **flexible in what data it can prove**. Virtually any piece of information a website can show to a logged-in user can be turned into a claim. This means a wide range of use cases can be served by the same infrastructure. For example, **education records, employment status, financial metrics, purchase history, social reputation, and more** can all be verified. The documentation lists use cases like *education verification* (proving where and what someone is studying), *employment verification* (proving someone works at a certain company), *financial background* (credit scores, investor accreditation), *shopping history* (loyalty or spending patterns), and many others. Such data points cover industries from **ride-sharing** (proving driver ratings or trip counts) to **SMB lending** (proving a small business’s revenue via their online store or bank statements), **education** (proving degrees or course completions from a university portal), **commerce/marketing** (proving a customer’s VIP status or purchase volume on an e-commerce site for tailored rewards), and beyond. With Reclaim, **developers can craft custom “proofs” for their specific needs** – whether it’s verifying a user’s GitHub contributions for an open-source grant or confirming a gamer’s achievements from a gaming platform for a tournament qualification. The key is that the **framework is universal**, not one verification per provider. This versatility means **product managers can get creative with trust signals** in their platforms, knowing that Reclaim can likely fetch whatever data is needed.

* **AI-Assisted Verification and Integration:** Reclaim Protocol leverages artificial intelligence to **streamline and scale the integration of new data sources**, making it even more powerful over time. Initially, adding support for a new website’s data might require defining where to fetch the data (URL, JSON/XPath, etc.), which was a manual process. To remove this bottleneck, the Reclaim team built a developer tool and then infused it with AI. **AI assists in automatically identifying and handling the target data on web pages**, greatly reducing the effort to support new providers. For example, the system can use an LLM to guess which page or API contains the needed info and find the correct path to it – essentially automatically creating a “provider” definition by just being told what info is needed. This means if a developer or product team wants to use Reclaim for a site that isn’t yet configured, an AI can often generate the integration logic on the fly when a user first attempts it, **without human intervention**. AI is also used to **maintain resilience**: if a website’s layout or HTML changes (which could break a hardcoded parser), Reclaim’s AI can detect the change and adjust the data extraction strategy automatically. In other words, the system self-heals and adapts to minor site updates, reducing downtime. These capabilities dramatically **speed up time-to-market** for new verifications and ensure Reclaim’s data coverage keeps growing. Already, the community (using Reclaim’s dev tool) has created **hundreds of new site integrations** with little friction, and AI is taking this even further by cutting down the provider setup from potentially days to literally seconds. This AI-assisted approach is a major USP because it means **Reclaim can keep up with the ever-changing web at scale**, something that would be impossible with manual integration alone.

* **Lowest Cost of Verifiability:** Reclaim Protocol delivers verifiability at a very low cost compared to traditional methods. There are a few reasons for this. First, it runs primarily off-chain (entirely off-chain if on-chain proofs are not needed), avoiding the high costs of on-chain oracles or transactions for every verification. The heavy cryptographic work (like proof generation) is done on the user’s device and attestor service, which is far more cost-efficient than involving blockchain computation for each proof. If an application *does* want on-chain verifiability (for example, to use a proof in a smart contract), Reclaim supports that via succinct proofs that can be posted or verified on-chain with minimal gas (using its **zkFetch** and on-chain SDKs). In most cases, however, the verification can be done server-side or in-app by simply checking a digital signature, which is practically free. Additionally, Reclaim’s **scalability and automation (including the AI automation)** drive down the marginal cost of supporting new data sources or maintaining them. There’s no need for armies of people to verify documents or for custom API integrations – one unified protocol handles everything. This makes the per-verification cost extremely low. Finally, by **enabling users to re-use existing trusted data**, companies can save on costly alternatives like manual KYC checks, credit bureau lookups, or lengthy onboarding processes. In summary, Reclaim offers perhaps the **most cost-effective way to achieve trust** in user-provided data, by leveraging cryptography and existing infrastructure (the web itself) rather than expensive third-party verification services.

## Example Use Cases Across Industries

To make it more concrete, here are a few example scenarios where Reclaim Protocol can be applied:

* **Ride-Sharing and Mobility:** A new ride-hailing startup wants to onboard drivers quickly and ensure safety. Using Reclaim, they can ask drivers to prove their reputation from another platform. For instance, a driver can verify *“I have a 4.9 star rating on Uber with over 500 trips”* by logging into Uber via Reclaim – the startup’s app then gets a proof of the rating without seeing the driver’s Uber credentials or full data. This can also work for riders (e.g. proving you have a good rider rating or no bans, to join an exclusive carpool club). It provides trust based on past behavior, which is valuable for any peer-to-peer service.

* **SMB Lending and Fintech:** A fintech lender serving small businesses needs to assess creditworthiness rapidly. Rather than requiring extensive paperwork, they use Reclaim to let applicants prove financial metrics from their existing accounts. For example, a business owner could prove their **monthly revenue by connecting to their payment processor or e-commerce store**, or prove their bank account balance and history by logging into online banking. The lender receives cryptographically assured data like *average account balance*, *number of sales last quarter*, or *credit score range* pulled directly from trusted sources (bank, QuickBooks, Stripe, etc.). This speeds up loan decisions while reducing fraud, as the data is verified at the source.

* **Education and Online Learning:** An education platform or employer might need to verify someone’s academic credentials or course completions. With Reclaim, a user can prove **they graduated from a certain university or are currently enrolled**, by logging into the university’s student portal or alumni database. They could also prove completion of a MOOC (Massive Open Online Course) or professional certificate from a site like Coursera. The proof could state *“User has completed the XYZ Data Science course on Coursera”* with a credential signed by Reclaim (which fetched the completion status from Coursera’s API or webpage). This is valuable for hiring (verify skills), student discounts, or professional networking without having to manually check documents.

* **E-Commerce and Customer Loyalty:** Marketers can tailor offers if they can verify customer behavior across platforms. For example, a luxury retail site could ask a user to prove **their purchase history from another store** to qualify for a VIP program. Using Reclaim, the user might prove *“I have spent over \$5,000 on Amazon in the past year”* or *“I bought product X from Store Y”* by fetching order history from those accounts. The proof would show only the necessary info (e.g. total spend, or purchase of that product) and not the entire order list, preserving privacy. Similarly, **loyalty programs** could be bridged: e.g. prove you are a gold-tier member on an airline to get status on a partner hotel chain – done by pulling your account status page via Reclaim. In commerce, this opens up cross-platform personalization that was previously not possible due to data silos.

* **Social and Web3 Reputation:** (Beyond the four industries mentioned, another example) A decentralized app (dApp) or online community might want to gate access based on Web2 reputation signals. Using Reclaim, a user could verify things like their **GitHub contributions (for developer communities)**, their **StackOverflow reputation (for Q\&A sites)**, or their **Twitter/X follower count and account age** – all as proofs. For instance, a DAO could require proving you have at least 1000 GitHub stars or that your Twitter account is over 3 years old and not a bot. Reclaim would fetch those data points via the web and the DAO’s smart contract (with Reclaim’s on-chain SDK) could verify the proof before allowing access or granting roles.

These examples only scratch the surface. Because Reclaim is essentially a general-purpose **“proof of anything from the internet”** tool, creative product teams can adapt it to countless scenarios. It enables **trust and personalization based on real user data** in a way that was never possible before at scale.

## User Experience and Integration Flow

Despite the complex tech under the hood, Reclaim Protocol is designed to be simple and seamless for end-users. A typical user experience to import data from a website looks like this:

* **Initiation:** The user is in an application (mobile or web) that wants some verified data. For example, a lending app might have a button: “Verify your bank balance” or a job site might say “Connect your LinkedIn to verify employment.” When the user agrees, the app initiates a Reclaim verification request in the background and then presents the user with a prompt (like “Click to verify via Reclaim”).

* **Instant App Launch:** If the user is on a mobile device, tapping the verification link **launches the Reclaim Verifier App instantly via an App Clip (iOS) or Instant App (Android)**. This is essentially a tiny, on-demand app that does not require a full install from the app store. The user is not forced to download any new app – it opens immediately when they click the link or scan the QR. (On web or desktop, the flow can present a QR code for the user’s phone. The user would scan it and that would launch the verifier app on their phone. This connects back to the web session.) The use of App Clips/Instant Apps keeps friction extremely low: **within seconds, the user is in a dedicated secure environment ready to perform the verification, without any heavy installation overhead**. The mini-app is fully sandboxed and vetted (App Clips are subject to the same security reviews by Apple/Google), giving confidence in security.

* **Login and Data Selection:** The verifier app will present the target website’s login page or relevant interface in an embedded browser view. The user proceeds to **log in as usual** (entering username/password or using OAuth if available – any normal login method works). Because this is essentially a real browser under the hood, **the experience is identical to logging in directly on that website**, except that the user knows they are doing it to produce a verification. Once logged in, the app may guide the user (if needed) to navigate to the page where the required information is shown, or this may happen automatically. Often it’s as straightforward as logging in and clicking “Allow” for the data to be captured (depending on how the provider is configured). The user can often **see the data that will be shared and confirm consent**. For instance, the app might highlight “Balance: \$5,000 will be shared” or “Your 5-star rating will be shared, but not your personal info.”

* **Completion:** After the required data is obtained and the proof is generated (this usually takes only a couple of seconds of computation), the user sees a confirmation that verification succeeded. The Reclaim App Clip then **redirects the user back to the original application automatically**. If it was launched via a link, it closes and returns focus to the original app. If the flow was initiated via scanning a QR on a desktop web, the web app will have been polling for the result and now sees that the proof is complete. From the user’s perspective, they might just see a quick “Verified!” message or get taken to the next step on the site.

* **No Persisting App:** Because everything happened via a lightweight ephemeral app session, the user doesn’t end up with a new app cluttering their phone. It was as if the functionality was built into the original app. (For deeper integrations, some apps may integrate Reclaim’s SDK natively, so users verify within the app’s own interface. In that case, the experience is *truly* native: e.g. the Uber verification screen appears as a part of the app itself via a webview. But whether using App Clip or native SDK, the flow is very similar.)

This **“no-download, no-hassle” flow is critical for user adoption**. It means verifying data via Reclaim is almost as easy as a standard OAuth “Sign in with X” flow from the user perspective – but with the huge advantage of provable trust. The user is always kept in control: they authenticate directly with the source site (so they know their credentials only go to the site itself), and they explicitly allow the data to be shared. The app never sees the user’s credentials, and the user doesn’t have to hand over any passwords to a third party, alleviating security concerns.

## Security Guarantees and Trust Model

Security is at the heart of Reclaim Protocol’s design. The system provides several strong guarantees and has been analyzed by cryptographers to ensure the integrity and privacy of the verification process. Here are the key security aspects:

* **Authenticity of Data (Trust in Attestor’s Attestation):** Reclaim’s proofs come with a cryptographic attestation from the attestor that vouches for the data’s origin. The attestor is essentially a **trusted witness** that has no incentive to lie because its reputation (and in decentralized versions, economic stake) is on the line. For a proof to be accepted, it must be signed by a recognized attestor key. This means relying parties **trust the attestor’s signature** similar to how one trusts a certificate authority in TLS. However, to remove any single point of trust, Reclaim is moving toward **multi-attestor verification** – where multiple independent attestors must corroborate a claim. In a decentralized attestor network, each attestor could be run by different organizations or community members, and **a claim is only accepted if, say, 2-out-of-3 or a majority sign off**, significantly reducing the chance of any fraud. Additionally, a system of **economic incentives and penalties** is planned: attestors will stake tokens and can be slashed for wrongful attestation, and they earn fees for honest work. This makes the attestor layer **self-regulating and trust-minimized**, approaching the security level of decentralized oracles.

* **User Privacy and Minimal Disclosure:** Reclaim is built to **never expose more data than necessary**. The user’s sensitive information (like login credentials, session cookies, or unrelated personal data on a page) is never revealed to the attestor or the relying party. During the session, the attestor cannot decrypt the content due to end-to-end TLS encryption. The user’s device only shares the specific pieces of data required for the proof, and even those can often be turned into yes/no or range proofs via ZK techniques. For example, the proof might simply say “Age > 18: True” rather than revealing the actual birthdate. This selective disclosure is enabled by the **zero-knowledge proof framework** integrated in Reclaim. As a result, users don’t have to trade privacy for convenience – they maintain control over what exactly is shared. Moreover, Reclaim takes measures to ensure that **multiple credentials of the same user cannot be easily linked** by outsiders. Techniques like OPRF-derived unique IDs and per-proof randomness mean that two proofs issued for the same user on different sites do not contain common identifiers. This prevents a verifier from correlating, for example, your bank proof and your Uber proof as coming from the same person, unless you explicitly want to link them. In summary, **privacy by design** is a core principle: the protocol proves *the truth of statements* without unveiling the raw data behind them.

* **No Credential Sharing & Impersonation Resistance:** Unlike some naive approaches where a service might ask for a user’s passwords or cookies to fetch data (a **terrible practice** that some scrapers use), Reclaim **never requires users to hand over their long-term credentials to anyone except the official site**. The user logs in directly to the site in a secure context. The attestor never sees the plaintext password or captures the session cookie (it might see an encrypted token pass by but cannot read it). Also, Reclaim’s design often involves the user’s device **injecting the credentials directly into the TLS tunnel** in a way that the attestor can’t intercept (this can be done using secure enclaves or splitting secrets). By **avoiding credential disclosure**, Reclaim ensures that even if an attestor or some component turned malicious, it cannot later impersonate the user on the source site. The attestor cannot hijack the session because it doesn’t have the auth cookies (they remain encrypted or ephemeral). This is a stark contrast to web scraping tools that often **store and reuse user session cookies**, creating huge risk. Reclaim’s approach is fundamentally read-only and user-consented – it’s technically infeasible for the infrastructure to perform actions on the user’s account or extract extra data beyond what the proof needs.

* **Integrity of the Connection (Mitigating MITM, DNS/BGP Attacks):** Since the attestor acts as a network proxy, it is positioned to verify the connection’s integrity. It performs **SSL/TLS certificate validation** for the target site on behalf of the user. This means if an attacker somehow tried to trick the user to connect to a fake domain or intercept the traffic, the attestor would detect a certificate mismatch or an untrusted CA and abort. This protects against man-in-the-middle attacks, including DNS poisoning (resolving the domain to a malicious IP) or BGP route hijacking, *as long as the attacker cannot obtain a valid TLS certificate for the target domain*. Modern web security (HSTS, certificate transparency logs, etc.) combined with attestor checks make such attacks highly unlikely to succeed unnoticed. The attestor essentially adds an extra layer of defense: even if a user’s device or network were compromised to point to a wrong server, the attestor’s independent validation of the domain’s cert would catch it. Furthermore, because the attestor **does not terminate TLS but only forwards it** (opaque proxy), it can’t fiddle with the traffic undetected; any tampering would break the cryptographic checks and be caught by the client. The protocol can also include cryptographic evidence (like a hash of the server’s public key or a signature from the server if available) in the proof to show the server was genuine. The recent research paper *“Proxying is Enough”* formalizes that Reclaim’s approach (where the verifier is in-line observing the TLS) can guarantee data integrity under these conditions, especially for common protocols like HTTPS which include some variable padding and structure that prevent undetected tampering.

* **Open Source and Formal Audits:** The Reclaim Protocol’s core is being open-sourced (it has already open-sourced significant parts of the client side and proof generation code). This means the community and security researchers can audit how it works. Additionally, a **formal security analysis** has been published (on IACR ePrint) that scrutinizes the protocol’s cryptographic security. Having peer-reviewed academic analysis provides confidence that the scheme doesn’t have obvious flaws. The team has also run internal and external audits on components like the ZK circuits, the mobile apps, etc., to ensure robustness. They also frequently address potential attack vectors in their blog (for example, a detailed breakdown of a theoretical attack and why it fails shows their commitment to transparency in security). The bottom line is that **Reclaim stands on solid cryptographic foundations**, giving both users and applications peace of mind.

In summary, Reclaim Protocol’s security model assumes you trust the attestor(s) to perform honest verification, but it does everything possible to minimize the level of that trust required and to protect the user. With end-to-end encryption, selective disclosure, decentralized attestors, and rigorous checks, the system is highly resilient to common threats. Users’ accounts remain safe, their data remains private, and relying parties get high-assurance proofs. It’s a balancing act of practicality and security that Reclaim executes via cutting-edge cryptographic engineering.

## Performance and Device Benchmark Highlights

One might wonder if all these cryptographic operations and proofs slow things down. In practice, Reclaim Protocol has achieved **impressive performance optimizations**, even on mobile devices, ensuring a smooth user experience. The protocol was designed so that the **heavy lifting (like zero-knowledge proof generation)** happens on the client device in just a few seconds, and attestor signature verification is near-instant.

Early versions using a JavaScript ZK prover could take some dozens of seconds for complex proofs, but the team has since overhauled their proof generation stack for efficiency. They migrated from a snarkjs (WASM-based) implementation to a highly optimized Rust/Go-based proof system (using **Gnark** libraries for zero-knowledge) that runs natively on mobile. The results have been dramatic: **average proof generation time dropped from around 40 seconds to about 4–5 seconds** after these optimizations. For common simpler proofs, it’s even faster. For instance, generating a proof of a GitHub username claim now takes **under 3 seconds on a typical phone**. These speeds were recorded on real mobile hardware, indicating that even low-end smartphones can handle Reclaim proofs quickly without the app freezing or crashing.

Memory usage was another challenge on mobile (since ZK computations can be memory intensive), but the move to native code and careful engineering has allowed the proof generation to run reliably within the constraints of iOS and Android. The team reports they can now generate **dozens of proofs in sequence (100+ in tests) without performance degradation or crashes**, whereas earlier approaches would slow down after 20-30 proofs. This means Reclaim can scale to multiple claims in one session if needed (though usually one proof is enough). It also means a user could reuse the verifier app many times without needing to restart it.

On the attestor side, signing a claim and verifying the relevant data is very fast (network latency to the target site is typically the longest part). The attestation service can handle large numbers of concurrent sessions, and because much of the work is just forwarding encrypted packets, it’s network-bound more than CPU-bound. The protocol has already handled over a million verifications and proven it can operate at scale (with caching and load balancing for attestors to serve even more).

For developers, these performance gains translate into a snappy experience for their users – a verification via Reclaim often **completes in just a few seconds of waiting time**, which is acceptable in most UX flows. In scenarios where multiple proofs must be generated (say, verifying 3 different accounts at once), these can sometimes be parallelized or done back-to-back within a single App Clip session.

Finally, the Reclaim team continues to push the boundaries on performance. They are exploring things like incremental proving, lighter circuits for common cases, and even hardware-accelerated proving. But as of now, the **benchmark is that a proof is typically ready in 3–5 seconds on a modern smartphone**, which is quite user-friendly. This is a key enabler for adoption – users are impatient, so keeping the wait time low ensures people don’t abandon the process.

## Developer Integration and SDK Tips

For product managers and developers, one of the reassuring aspects of Reclaim Protocol is that **integrating it into your product is straightforward**. You don’t need to be a cryptography expert – the team provides SDKs and a simple API to work with. Here’s an overview of how a developer would integrate Reclaim, in terms of steps and a sample code snippet:

* **Multi-Platform SDKs:** Reclaim offers SDKs for all major platforms. There’s a JavaScript/TypeScript SDK for web frontends and Node.js backends, mobile SDKs for iOS, Android, React Native, Flutter, Ionic, and even on-chain verification libraries for smart contracts. This means you can use Reclaim in a web app, a native mobile app, or even in a blockchain context depending on your product. The integration experience is meant to feel native to your stack.

* **Basic Integration Flow:** As outlined earlier, the integration involves two main parts – the front-end/UI and the back-end verification. On the backend (or your server), you will set up an application in the Reclaim Dev Tool to get an APP_ID and APP_SECRET (like API keys). You’ll also select which data providers you plan to use (for security, only pre-approved providers for your app can be requested). On the front-end, you use the SDK to initiate proof requests and handle responses.

  The typical steps your code will do are:

  1. **Initialize a proof request** with your App ID/Secret and the provider (which represents the target data source and specific credential you want).
  2. **Generate a verification link or QR code** for the user to open the Reclaim verifier on their device.
  3. **Wait for the proof to be completed**, then receive the result (either via a callback, promise, or by polling the SDK’s status).
  4. **Verify the proof’s authenticity** (the SDK or Reclaim backend does this for you) and then use the data in your application logic (e.g., mark user as verified, store the claim data, etc.).

* **Code Snippet Example:** Below is a simplified example in JavaScript using the Reclaim JS SDK (suitable for a web app). This shows how you might start a proof request for a hypothetical provider (e.g., “Uber ride count proof”) and handle the response:


import { ReclaimProofRequest } from '@reclaimprotocol/js-sdk';

// 1. Initialize the Reclaim proof request with your application credentials and provider ID
const proofRequest = await ReclaimProofRequest.init(APP_ID, APP_SECRET, PROVIDER_ID);

// 2. Generate a verification URL for the user to complete the proof
const verificationUrl = await proofRequest.getRequestUrl();
console.log("Please visit this URL to verify:", verificationUrl);
// (In a real app, you would embed this URL in a QR code or an "Open App Clip" button for the user)

// 3. Start the session and define callbacks for success or failure
await proofRequest.startSession({
  onSuccess: (proof) => {
    console.log("Verification successful! Proof data:", proof);
    // Here you can process the proof, e.g., extract claimData and update user status
    // proof.claimData.context might contain the verified info
  },
  onFailure: (error) => {
    console.error("Verification failed:", error);
  }
});

<small>*The above snippet is illustrative. In practice, you might trigger startSession and then redirect the user, etc., as per the SDK usage.*</small>

In this example, the front-end calls getRequestUrl(), which gives a URL that the user should visit with their mobile device (it could be presented as a QR code for convenience). The startSession call essentially tells the SDK to begin listening for the result (and optionally opens the URL in a new tab if you want). The user does the whole verification on their mobile, and once done, the onSuccess callback is triggered with the proof object. The proof contains the signed claim and the data you care about. The SDK abstracts the polling mechanism – under the hood it was checking the status URL or waiting for a redirect.

On the backend side (if you want extra security), you can also receive a webhook or query the Reclaim service to double-check the proof’s signature. But the SDK handles signature verification for you, so when you get onSuccess(proof), you can trust that it’s valid. If you prefer not to rely on front-end for verification, you can send the proof token to your server and use the Reclaim **backend SDK (or REST API)** to verify it server-side, which is a common practice for final validation. The Reclaim backend SDK (for Node.js, Python, etc.) makes this a one-liner to validate a proof’s signature and contents.

* **Integration Tips:**

  * It’s important to pre-configure the providers your app will use in the Dev Tool; this ensures security (your App ID can’t suddenly request data from a provider you didn’t approve). However, adding providers is easy via the dashboard.
  * Branding: When the user launches the App Clip/Instant App, they will see your application name and logo (which you set in the Dev Tool). This maintains a seamless feel – users know the verification is linked to your service.
  * Testing: You can test the integration with any provider using demo accounts. Reclaim provides a **local development mode** and test attestor setup if needed, though for most cases using the staging environment keys is enough to simulate flows.
  * On-chain use: If your use case involves smart contracts (like gating an NFT by a Web2 proof), Reclaim has **on-chain verification SDKs** and even example Solidity code to verify the proofs. Essentially, the attestor’s signature can be checked in a contract, or a zkSNARK can be emitted for certain data. This is more advanced, but it opens up decentralized applications to Web2 data (a powerful concept).

* **Support:** The Reclaim team is quite responsive on their Telegram and forums. They even offer to help write the integration if you face any issues. The documentation includes a quickstart and full examples for common stacks (React frontend + Express backend, etc.), so developers can often copy those as a starting point.

Overall, integrating Reclaim Protocol is designed to be **developer-friendly**. Product managers can take comfort that adding this functionality won’t require months of engineering R\&D – it’s more like a few days of work to plug in, depending on the complexity of the use case. The heavy lifting (the cryptography, the cross-platform app logic) has been encapsulated in the SDK. This allows teams to focus on how to use the verified data, rather than how to implement the verification itself.

---

**Sources:** The information above is drawn from the official Reclaim Protocol website, documentation, and whitepapers, including overviews, technical explainers, and blog posts by the Reclaim team detailing cryptographic design and use cases, as well as formal security analysis of the protocol. These sources provide further detail on how Reclaim achieves secure, private, and scalable verification of web-sourced data.
---
`

const aboutReclaimShort = `
**Reclaim Protocol** enables users to fetch and share verifiable data from any website—**without API access or server cooperation**. It empowers businesses to verify facts like account balances, employment, education, ride history, and more from 2,500+ Web2 platforms using **zero-knowledge proofs (ZKPs)** and **TLS provenance**, all while preserving privacy.

A user logs in to the target website via Reclaim’s secure verifier (e.g. App Clip/Instant App or an inApp SDK), which routes traffic through a trusted attestor. The attestor **cannot decrypt or access sensitive info** but observes enough to verify that the data truly came from the intended source. The user then selectively reveals only necessary data, which is wrapped into a **cryptographically signed proof**.

These **Reclaim proofs** can be verified by your backend using SDKs (JS, iOS, Android, Solidity) to confirm authenticity and data integrity—without contacting the original site.

### Key Benefits:

* **Global data access**: Works with any HTTPS website across geographies.
* **Lowest cost verifiability**: No on-chain gas needed; proofs are generated off-chain.
* **AI-assisted integrations**: New data sources can be added in seconds.
* **Enterprise-ready UX**: Instant launch, no app install needed, <5s proof time.

### Example Use Cases:

* Ride-hailing: Prove 4.9+ Uber rating for fast-track onboarding.
* SMB lending: Share verified Amazon/Shopify GMV or bank balance.
* Education: Verify enrollment from university portals.
* E-commerce: Prove loyalty status from past purchases.

Reclaim is open source, audited, and privacy-focused. Users stay in control. You get verified data you can trust.

**Website**: [reclaimprotocol.org](https://reclaimprotocol.org)
**Docs**: [docs.reclaimprotocol.org](https://docs.reclaimprotocol.org)
**SDK**: [github.com/reclaimprotocol](https://github.com/reclaimprotocol)
`
module.exports = {
    aboutReclaimLong,
    aboutReclaimShort
};